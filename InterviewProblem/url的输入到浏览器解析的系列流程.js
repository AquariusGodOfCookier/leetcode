
    // url的输入到浏览器解析的系列流程
    /**
    * 1:先查看你的本地缓存，浏览器缓存，内存缓存中是否有该域名对应的ip地址
    * 2:如果没有，通过dns解析找到该域名对应的ip地址
    * 3:找到改ip地址服务器，发起一次tcp连接请求
    * 4:建立了tcp连接，发送http请求报文，发送到服务器指定端口，建立http连接请求
    * 5:服务器处理请求并返回http报文，html,css,js就在响应报文中
    * 6:浏览器接受http报文，执行浏览器渲染机制
    */

    // dns解析
    /**
     * dns是domain name system 域名系统，用来管理域名与ip地址的映射关系
     * 如果本地缓存中没有改域名对应的ip地址，就通过递归查询域名服务器，从根域名服务器，到二级域名服务器，到三级域名服务器
     * 返回该域名对应的ip地址
     */

     // tcp连接三次握手
    /**
     * 第一次握手:客户端和服务器端发起通信，首先告知服务器我要发起tcp连接请求了，发送syn=1到服务器，并且客户端进入到请求连接状态
     * 第二次握手:服务器端接收到客户端发起的请求，收到syn，此时返回给客户端一个确认信息，我接收到你的请求了，我准备好了，你现在能连接吗，发送syn+ack
     * 第三次握手:客户端接收到服务器端的syn+ack状态包，向服务器端发送一个ack，代表我接收到了，现在开始联通把
     */
    // tcp连接四次挥手
    /**
     * 因为tcp协议是全双工的，因此每个方向必须单独进行关闭，一方发送fin，代表这一方不发送数据，但不代表另一方不发送数据
     * 服务器端还是客户端都可以发起接触连接请求，假设客户端发起的解除请求
     * 第一次挥手:客户端向服务器端发送fin，表示我说完了，想要断开通信协议，此时客户端处于等待结束连接状态
     * 第二次挥手:服务器端知道了客户端想要结束连接，同意关闭连接，发送一个ack确认
     * 第三次挥手:服务器关闭与客户端的连接，也发送了一个fin给客户端，此时服务器端处于等待连接结束状态
     * 第四次挥手:客户端接收到服务器端发送的fin包，知道服务器端也可以断开连接了，就给服务器端发送一个ack确认，服务器端接受到这个ack就关闭连接。客户端等待2msl（报文最大生存时间），如果没有返回，就默认服务器端关闭了，客户端也就关闭自身链接
     */

 // 重排与重绘 + 浏览器渲染机制
 /**
  * 浏览器渲染机制
  * 接受到服务器端发来的html，css，js资源文档，解析，渲染布局，绘制
  * (1) 解析html文档，生成dom树，包括js生成的标签
  * (2) 解析css，生成cssom规则树，重叠样式表规则树
  * (3)合并dom与cssom，生成渲染树
  * (4)遍历渲染树，从根结点递归调用，计算每一个元素的大小，位置，属性等信息
  * (5)将渲染树中的每个节点绘制到屏幕上
  * 
  * 解析html文档:
  * 通过html解释器把html文档转换成树的形式，根结点是html，遇到加载js和css元素，html解析器将控制权转接给js解析器或css解析器，
  * 如果该js操作了css，就会延迟js脚本执行，知道cssom树构建完成，构建dom树
  * 解析css文档:
  * 通过css解析器把css文档转换成stylesheet对象，每个对象包括样式规则
  * 
  * 重排与重绘
  * 重排:当渲染树中的一部分因为元素的尺寸，布局，隐藏等改变而需要重新构建，就称之为重排
  * 重绘:当元素的位置，大小属性等确定下来以后，浏览器将渲染树中的每个节点都绘制到屏幕上。当一个元素的外观改变触发浏览器行为，根据元素的新属性重新绘制，称为重绘
  * 不影响布局，一般是重绘，影响布局是重排
  * 浏览器初次渲染的时候会执行一次重排重绘
  * 重排必定重绘，重绘不一定重排
  */

