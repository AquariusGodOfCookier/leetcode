 // js数据类型
 /**
  * js数据类型分为基本数据类型与引用数据类型
  * 基本数据类型分为:number,string,boolean,null,undefined,symbol
  * 引用数据类型分为:object,function,array
  * 原始数据类型直接存储在栈中
  * 引用数据类型栈中存储指针，指向堆中该实体的起始地址
  */

 // 判断js类型方法
 /**
  * 1: typepf 但是null也是object
  * 2：instanceof 获取原型链上的属性
  * 3：object.prototype.tostring.call()
  * 4: isArray
  */

 // 事件的三个阶段
 /*
  * 捕获，目标，冒泡
  * 事件先捕获，直到达到目标，在冒泡排除
  * 事件委托是值将事件绑定目标元素的父元素上，利用冒泡机制触发该事件
  *  
  */

// 事件流分为捕获阶段与冒泡阶段
// 事件冒泡：从触发的时间开始，事件不断往上传递
// 事件捕获：从dom树一直不断向下传递事件直到被捕获
// ie的事件流为事件冒泡流
// js中事件冒泡我们知道，子元素身上的事件会冒泡到父元素身上。
// 事件代理就是，本来加在子元素身上的事件，加在了其父级身上。
// 那就产生了问题：父级那么多子元素，怎么区分事件本应该是哪个子元素的？
// 答案是：event对象里记录的有“事件源”，它就是发生事件的子元素。
// 它存在兼容性问题，在老的IE下，事件源是 window.event.srcElement，其他浏览器是 event.target
// 用事件委托有什么好处呢？
// 第一个好处是效率高，比如，不用for循环为子元素添加事件了
// 第二个好处是，js新生成的子元素也不用新为其添加事件了，程序逻辑上比较方便

 // 闭包
 /**
  * 声明在一个在函数中的函数，用于让外部访问函数内部变量，可以避免使用全局变量造成全局污染
  * 函数套函数，内部函数可以引用外部函数变量，参数和变量不会被垃圾回收机制回收
  */

 // js垃圾回收机制
 /**
  * 什么是垃圾 
  * 垃圾就是不能被根直接或间接被引用的对象，就是垃圾，就要被清除。
  * 垃圾清除方法
  * js引擎会在一定时间间隔内扫描执行上下文，从跟开始
  */
 //    Javascript 垃圾回收方法
 // 标记清除（mark and sweep）
 //  这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，
 //  垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
 //  垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，
 //  然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），
 //  在这些完成之后仍存在标记的就是要删除的变量了
 // 引用计数(reference counting)
 // 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。
 //  引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，
 // 如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，
 //  因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间



// apply call
// var numberList = [1,2,3,4,5];
// console.log(Math.max.apply(Math,numberList))
// console.log(Math.max(numberList))
// function log(){
//     let args = Array.prototype.slice.apply(arguments);
//     args.unshift('(app)');
//     console.log.apply(console,args)
// }
// log(1,2,34)